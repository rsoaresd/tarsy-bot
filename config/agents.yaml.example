# Configuration-Based Agents - Example Configuration File
# =======================================================
# 
# This file demonstrates how to define custom agents and MCP servers
# using YAML configuration instead of hardcoded Python classes.
#
# To use this configuration:
# 1. Copy this file to ./config/agents.yaml
# 2. Customize the agents and MCP servers for your environment
# 3. Set AGENT_CONFIG_PATH=./config/agents.yaml in your .env file (optional - this is the default)
# 4. Set required environment variables in your .env file for template substitution
#
# IMPORTANT NOTES:
# - Agent names and MCP server IDs must be unique across configured and built-in components
# - Each agent must handle at least one alert type and use at least one MCP server
# - Configured agents can use both built-in MCP servers (like "kubernetes-server") and configured ones
# - Alert types can only be handled by one agent (no conflicts allowed)
#
# TEMPLATE VARIABLES:
# - MCP server configurations support ${VARIABLE_NAME} template syntax
# - Template variables are resolved using environment variables from your .env file
# - Built-in servers (like kubernetes-server) also support template variables
# - Missing environment variables will cause startup errors - ensure all required variables are set
# - Template variables can be used in args, command, and other string fields
#
# ITERATION STRATEGIES:
# - Each agent can use different iteration strategies for alert processing:
#   - "react": ReAct pattern with Think→Action→Observation cycles for complete analysis
#   - "react-stage": ReAct pattern for stage-specific analysis within multi-stage chains
#   - "react-final-analysis": ReAct final analysis only, no tools, uses accumulated data
# - Built-in agents have default strategies: KubernetesAgent uses "react"
# - Configured agents default to "react" if iteration_strategy is not specified
# - Choose "react" for standalone analysis, "react-stage" for chain stages, "react-final-analysis" for synthesis
#
# DATA MASKING:
# - MCP servers can include optional data_masking configuration to protect sensitive data
# - Built-in pattern groups: "basic" (api_key, password), "secrets" (basic + token), "security" (all + certificate), "kubernetes" (kubernetes_secret + basic), "all" (all patterns)
# - Custom patterns can be defined with regex pattern, replacement text, and description
# - Masking is applied to MCP server responses before reaching the LLM or logs
# - Set enabled: false to disable masking for specific servers
#
# RESULT SUMMARIZATION
# - MCP servers can include optional summarization configuration to handle large tool outputs
# - Summarization reduces context window bloat in ReAct conversations and database storage
# - Agent-provided summarizers use investigation conversation context for intelligent summarization
# - Configuration options:
#   - enabled: true/false (default: true) - Enable or disable summarization for this server
#   - size_threshold_tokens: integer (default: 2000) - Token count threshold for triggering summarization
#   - summary_max_token_limit: integer (default: 1000) - Maximum tokens allowed in summary (enforced at LLM provider level)
# - When disabled (enabled: false), all MCP tool results pass through unchanged regardless of size
# - Different servers may need different thresholds: security data often needs higher thresholds, filesystem operations often disabled
# - Summarization uses LLM provider's max_tokens parameter for guaranteed length control and cost management
#

# =============================================================================
# MCP SERVER CONFIGURATIONS
# =============================================================================
# Define custom MCP servers that agents can use for specialized functionality.
# These extend the built-in MCP servers and can be referenced by any agent.

mcp_servers:
  # Security-focused MCP server for threat analysis and security operations
  security-server:
    server_id: "security-server"
    server_type: "security"
    enabled: true
    connection_params:
      # Example: Custom security MCP server command with templated arguments
      command: "/opt/security-mcp/server"
      args: ["--mode", "production", "--log-level", "info", "--token", "${SECURITY_SERVER_TOKEN}"]
      environment:
        SECURITY_DB_URL: "postgresql://user:pass@security-db:5432/security"
        API_TIMEOUT: "30"
    instructions: |
      Security analysis MCP server instructions:
      - Always prioritize data security over service availability
      - Check for unauthorized access patterns in logs and metrics
      - Provide detailed security recommendations with risk assessments
      - Include compliance considerations (SOC2, GDPR, etc.) in responses
      - Escalate critical security incidents immediately
    data_masking:
      enabled: true
      pattern_groups:
        - "security"          # Built-in group: api_key, password, token, certificate
      custom_patterns:
        - name: "security_token"
          pattern: "(?i)(token|jwt|bearer)[\\\"']?\\s*[:=]\\s*[\\\"']?([A-Za-z0-9_\\-\\.]{40,})[\\\"']?"
          replacement: '"security_token": "***MASKED_SECURITY_TOKEN***"'
          description: "Security tokens and JWTs"
          enabled: true
        - name: "ssh_key"
          pattern: 'ssh-(?:rsa|dss|ed25519|ecdsa)\s+[A-Za-z0-9+/=]+'
          replacement: "***MASKED_SSH_KEY***"
          description: "SSH public keys"
          enabled: true
    # Result Summarization Configuration
    summarization:
      enabled: true                    # Enable summarization for security tool output
      size_threshold_tokens: 2500      # Higher threshold for security data (needs detailed analysis)
      summary_max_token_limit: 1200    # Allow longer summaries for security context

  # Monitoring and observability MCP server for performance analysis
  monitoring-server:
    server_id: "monitoring-server"
    server_type: "monitoring"
    enabled: true
    connection_params:
      command: "npx"
      args: ["-y", "@example/monitoring-mcp-server@latest", "--prometheus-url", "${PROMETHEUS_URL}", "--grafana-token", "${GRAFANA_TOKEN}"]
      environment:
        PROMETHEUS_URL: "http://prometheus:9090"
        GRAFANA_URL: "http://grafana:3000"
        ALERT_MANAGER_URL: "http://alertmanager:9093"
    instructions: |
      Monitoring and observability instructions:
      - Focus on performance metrics, resource utilization, and system health
      - Analyze trends and patterns in metrics data
      - Provide actionable recommendations for performance optimization
      - Include relevant dashboards and queries in responses
      - Consider both immediate fixes and long-term capacity planning
    data_masking:
      enabled: true
      pattern_groups:
        - "basic"             # Built-in group: api_key, password
    # Result Summarization Configuration
    summarization:
      enabled: true                    # Enable summarization for monitoring tool output
      size_threshold_tokens: 3000      # Higher threshold for metrics data (can be voluminous)
      summary_max_token_limit: 800     # Concise summaries for metrics and performance data

  # Custom cloud provider MCP server (example for AWS-specific operations)
  aws-server:
    server_id: "aws-server"
    server_type: "cloud"
    enabled: false  # Disabled by default - enable when AWS credentials are configured
    connection_params:
      command: "/usr/local/bin/aws-mcp-server"
      args: ["--region", "${AWS_DEFAULT_REGION}", "--access-key", "${AWS_ACCESS_KEY_ID}"]
      environment:
        AWS_PROFILE: "production"
        AWS_DEFAULT_REGION: "us-west-2"
    instructions: |
      AWS cloud operations instructions:
      - Use AWS CLI and APIs for infrastructure management
      - Always verify resource states before making changes  
      - Include cost implications in recommendations
      - Follow AWS Well-Architected Framework principles
      - Ensure proper IAM permissions and security groups
    data_masking:
      enabled: false          # No masking for raw AWS data - handled by AWS IAM permissions
    # Result Summarization Configuration
    summarization:
      enabled: false                    # Disable summarization for AWS tool output

# =============================================================================
# AGENT CONFIGURATIONS
# =============================================================================
# Define custom agents that handle specific alert types using configured MCP servers.
# Each agent specifies which alert types it handles and which MCP servers it uses.

agents:
  # Security-focused agent for handling security-related alerts
  security-agent:
    alert_types:
      - "SecurityBreach"          # Data breach or unauthorized access
      - "AccessViolation"         # Authentication/authorization failures
      - "SuspiciousActivity"      # Unusual user or system behavior
      - "ComplianceViolation"     # Regulatory compliance issues
    mcp_servers:
      - "security-server"         # Custom security MCP server (defined above)
      - "kubernetes-server"       # Built-in Kubernetes MCP server for cluster security
    iteration_strategy: "react"   # Use ReAct strategy for systematic security analysis
    custom_instructions: |
      You are a security-focused SRE agent specializing in cybersecurity incidents.
      
      PRIORITIES:
      1. Data security and compliance over service availability
      2. Immediate containment of security threats
      3. Detailed forensic analysis and documentation
      4. Coordination with security team and stakeholders
      
      APPROACH:
      - Immediately assess the severity and scope of security incidents
      - Take containment actions to prevent further damage
      - Gather evidence and maintain chain of custody
      - Provide clear recommendations for remediation
      - Include lessons learned and prevention strategies

  # Performance-focused agent for handling performance and resource issues
  performance-agent:
    alert_types:
      - "HighLatency"             # Service response time issues
      - "CPUSpike"                # High CPU utilization
      - "MemoryPressure"          # Memory exhaustion or leaks
      - "DiskSpaceWarning"        # Storage capacity issues
      - "NetworkCongestion"       # Network bandwidth or connectivity issues
    mcp_servers:
      - "monitoring-server"       # Custom monitoring MCP server (defined above)
      - "kubernetes-server"       # Built-in Kubernetes MCP server for cluster metrics
    iteration_strategy: "react" # Use react strategy for systematic performance troubleshooting
    custom_instructions: |
      You are a performance-focused SRE agent specializing in system optimization.
      
      PRIORITIES:
      1. Service availability and performance optimization
      2. Root cause analysis of performance bottlenecks
      3. Capacity planning and resource scaling
      4. User experience impact minimization
      
      APPROACH:
      - Quickly identify the root cause of performance issues
      - Implement immediate fixes to restore service levels
      - Analyze metrics and trends to understand patterns
      - Provide scaling recommendations and capacity planning
      - Focus on both immediate resolution and long-term optimization

  # Database-focused agent for handling database-related alerts
  database-agent:
    alert_types:
      - "DatabaseConnectionFailure"    # Database connectivity issues
      - "SlowQueryPerformance"         # Query performance degradation
      - "DatabaseDiskSpace"            # Database storage issues
      - "ReplicationLag"               # Database replication delays
    mcp_servers:
      - "kubernetes-server"            # Built-in Kubernetes MCP server only
    # iteration_strategy: "react"      # Optional: defaults to "react" if not specified
    custom_instructions: |
      You are a database-focused SRE agent specializing in database operations.
      
      PRIORITIES:
      1. Data integrity and consistency
      2. Database availability and performance
      3. Backup and recovery preparedness
      4. Query optimization and indexing
      
      APPROACH:
      - Ensure data integrity is never compromised
      - Identify and resolve database performance bottlenecks
      - Monitor replication health and consistency
      - Provide database optimization recommendations
      - Coordinate with DBA team for complex issues

  # Cloud infrastructure agent (disabled by default - requires cloud credentials)
  cloud-infrastructure-agent:
    alert_types:
      - "EC2InstanceFailure"           # EC2 instance health issues
      - "LoadBalancerUnhealthy"        # Load balancer configuration issues
      - "AutoScalingFailure"           # Auto-scaling group problems
      - "CloudWatchAlarm"              # CloudWatch metric thresholds
    mcp_servers:
      - "aws-server"                   # Custom AWS MCP server (currently disabled)
      - "kubernetes-server"            # Built-in Kubernetes MCP server
    custom_instructions: |
      You are a cloud infrastructure-focused SRE agent specializing in AWS operations.
      
      NOTE: This agent requires the aws-server MCP server to be enabled and properly configured.
      
      PRIORITIES:
      1. Infrastructure availability and resilience
      2. Cost optimization and resource efficiency
      3. Security and compliance in the cloud
      4. Automation and infrastructure as code
      
      APPROACH:
      - Leverage AWS services for scalable, resilient solutions
      - Always consider cost implications of infrastructure changes
      - Use Infrastructure as Code (CloudFormation/Terraform) when possible
      - Follow AWS Well-Architected Framework principles
      - Ensure proper monitoring and alerting for cloud resources

# =============================================================================
# AGENT CHAIN CONFIGURATIONS  
# =============================================================================
# Define sequential agent chains that process alerts through multiple stages.
# Chains enable multi-stage workflows where agents build upon each other's work.
#
# CHAIN CONCEPTS:
# - Each chain handles specific alert types through sequential stages
# - Stages execute in order, with later stages receiving accumulated data from previous stages
# - Agents can be reused across different stages with different iteration strategies
# - Single agents are treated as 1-stage chains for unified processing
#
# STAGE ITERATION STRATEGIES:
# - "react": Standard ReAct pattern for complete analysis (default)
# - "react-stage": ReAct pattern for stage-specific analysis within multi-stage chains
# - "react-final-analysis": Pure analysis using all accumulated data (no tool calls)

agent_chains:
  # Simple 2-stage security incident workflow
  security-incident-chain:
    alert_types: ["SecurityBreach", "AccessViolation"]
    stages:
      - name: "evidence-collection"        # Stage 1: Gather security evidence
        agent: "security-agent"
        iteration_strategy: "react-stage" # Focus on data collection and stage analysis
      - name: "security-analysis"          # Stage 2: Analyze collected evidence  
        agent: "security-agent"
        iteration_strategy: "react"       # Full analysis with recommendations
    description: "2-stage security incident investigation and response"

  # Advanced 3-stage Kubernetes troubleshooting workflow
  kubernetes-deep-troubleshooting:
    alert_types: ["KubernetesCritical", "PodCrashLoop"]
    stages:
      - name: "system-data-collection"     # Stage 1: Collect system metrics and status
        agent: "performance-agent"
        iteration_strategy: "react-stage" # Focus on gathering comprehensive data and stage analysis
      - name: "detailed-analysis"          # Stage 2: Deep dive analysis with tools
        agent: "database-agent"            # Different agent for specialized analysis
        iteration_strategy: "react-stage" # Collect additional data + stage-specific analysis
      - name: "final-diagnosis"            # Stage 3: Comprehensive diagnosis and recommendations
        agent: "performance-agent"         # Back to performance agent for final analysis
        iteration_strategy: "react-final-analysis" # Pure analysis, no additional data collection
    description: "3-stage deep Kubernetes troubleshooting with specialized analysis"

  # Multi-stage performance investigation chain
  performance-optimization-chain:
    alert_types: ["HighLatency", "CPUSpike", "MemoryPressure"] 
    stages:
      - name: "metrics-collection"         # Stage 1: Gather performance metrics
        agent: "performance-agent"
        iteration_strategy: "react-stage" # Data collection focus
      - name: "resource-analysis"          # Stage 2: Analyze resource utilization  
        agent: "performance-agent"
        iteration_strategy: "react-stage" # Additional data + stage-specific analysis
      - name: "optimization-recommendations" # Stage 3: Provide optimization plan
        agent: "performance-agent"
        iteration_strategy: "react-final-analysis" # Comprehensive recommendations
    description: "3-stage performance optimization with incremental analysis"

  # Complex 4-stage multi-domain incident investigation  
  cross-platform-incident-chain:
    alert_types: ["SystemFailure", "MultiComponentFailure"]
    stages:
      - name: "kubernetes-investigation"    # Stage 1: Kubernetes cluster analysis
        agent: "database-agent"             # Using database-agent for K8s analysis
        iteration_strategy: "react-stage" # Collect K8s data + initial analysis
      - name: "performance-investigation"   # Stage 2: Performance metrics analysis
        agent: "performance-agent" 
        iteration_strategy: "react-stage" # Collect perf data + analysis
      - name: "security-assessment"         # Stage 3: Security impact assessment
        agent: "security-agent"
        iteration_strategy: "react-stage" # Security data + assessment
      - name: "unified-incident-report"     # Stage 4: Comprehensive incident report
        agent: "security-agent"             # Security agent for final report (highest priority)
        iteration_strategy: "react-final-analysis" # Synthesize all data into final report
    description: "4-stage cross-platform incident investigation with unified reporting"

  # Simple single-stage chain (equivalent to direct agent usage)
  database-quick-fix:
    alert_types: ["DatabaseConnectionFailure"]
    stages:
      - name: "database-diagnosis"          # Single stage for simple issues
        agent: "database-agent"
        # iteration_strategy: "react"       # Uses agent default if not specified
    description: "Single-stage database issue resolution"

# =============================================================================
# CONFIGURATION VALIDATION NOTES
# =============================================================================
#
# The following validation rules apply to this configuration:
#
# 1. UNIQUE NAMING:
#    - Agent names must not conflict with built-in agent classes
#    - MCP server IDs must not conflict with built-in MCP servers
#    - Current built-in agents: KubernetesAgent
#    - Current built-in MCP servers: kubernetes-server
#
# 2. ALERT TYPE EXCLUSIVITY:
#    - Each alert type can only be handled by one agent
#    - No conflicts allowed between configured and built-in agents
#    - Current built-in alert types: kubernetes, NamespaceTerminating
#
# 3. MCP SERVER REFERENCES:
#    - All MCP servers referenced by agents must exist (built-in or configured)
#    - MCP servers can be temporarily disabled (enabled: false) but still referenced
#    - Agents will fail to initialize if they reference non-existent MCP servers
#
# 4. REQUIRED FIELDS:
#    - Agents must have at least one alert_type and one mcp_server
#    - MCP servers must have server_id, server_type, and connection_params
#    - All fields marked as required in the Pydantic models must be present
#
# 5. AGENT CHAIN VALIDATION:
#    - Chain IDs must be unique across built-in and configured chains
#    - All agents referenced in chain stages must exist (built-in or configured)
#    - Alert types can only be handled by one chain (no conflicts allowed)
#    - Each chain must have at least one stage
#    - Stage names within a chain must be unique
#
# =============================================================================
# DEPLOYMENT CHECKLIST
# =============================================================================
#
# Before deploying this configuration:
#
# 1. □ Copy this file to ./config/agents.yaml
# 2. □ Customize agent configurations for your environment
# 3. □ Configure MCP server connection parameters
# 4. □ Set required environment variables in .env for template substitution
# 5. □ Test MCP server connectivity independently
# 6. □ Enable only the MCP servers you have properly configured
# 7. □ Verify no alert type conflicts with existing built-in agents or chains
# 8. □ Configure agent chains for multi-stage workflows if needed
# 9. □ Verify all agents referenced in chains exist and are properly configured
# 10. □ Configure MCP result summarization thresholds for your server output patterns (EP-0015)
# 11. □ Test summarization behavior with large MCP tool outputs in development
# 12. □ Set AGENT_CONFIG_PATH in .env if using a different location
# 13. □ Test configuration validation: python -c "from tarsy.config.agent_config import ConfigurationLoader; ConfigurationLoader('./config/agents.yaml').load_and_validate()"
# 14. □ Monitor application startup logs for configuration errors
# 15. □ Verify agents and chains are properly registered in the ChainRegistry
# 16. □ Verify summarization interactions appear correctly in dashboard timeline
#
# ============================================================================= 